Mutation er til for at lave små ændringer i skemaet. En mutationsalgoritme skal være i stand til at sørge for mangfoldighed, således at skemaet ikke ender i et lokalt maksimum. 
Måden hvorpå dette foregår er ved at tage et individ, finde to helt tilfældige timer på skemaet og bytte disse ud. Dette producerer to variabler, som kan finpudses for at finde den bedste løsning. Mutationer har en procentvis chance for at forekomme, og et antal af mutationer, der maksimalt kan ske pr. individ. 

Koden herinder viser mutations funktionen, som er brugt i programmet.
\begin{lstlisting}
void mutation(individual individuals[]){
  int i = 0, j = 0, ran1Day = 0, ran1Week = 0, ran2Day = 0, ran2Week = 0, chance = 0, mutations = 0, temp = 0;

  for(i = 0; i < NUMBER_OF_INDIVIDUALS; i++){
    chance = rand()% 100;
    mutations = rand()% MAX_MUTATIONS_PER_INDIVIDUAL;
    for (j = 0; j < mutations; j++){
      if (chance > CHANCE_OF_MUTATION){
        do {
          ran1Week = rand()% SCHOOL_DAYS_IN_WEEK;
          ran1Day = rand()% LESSONS_PER_DAY_MAX;
          ran2Week = rand()% SCHOOL_DAYS_IN_WEEK;
          ran2Day = rand()% LESSONS_PER_DAY_MAX;
        } while ((ran1Week == ran2Week) && (ran1Day == ran2Day));
        
        temp = individuals[i].individual_num[ran1Day][ran1Week];
        individuals[i].individual_num[ran1Day][ran1Week] =        individuals[i].individual_num[ran2Day][ran2Week];
        individuals[i].individual_num[ran2Day][ran2Week] = temp;
      }
    }
  }
}
\end{lstlisting}

Der bliver kørt gennem tre for-løkker. Den første tæller klassen op, så der bliver lavet mutationer på 7.a, så 7.b osv. Dernæst bliver der kørt gennem endnu en for-lykke, som går igennem antallet af individer, hvorefter et tilfældig tal mellem 0 og genereres. Hvis det generede tal er mindre end den valgte chance for mutation, forekommer mutationen. Antallet af ændringer ved en mutation vælges tilfældigt mellem 0 og det højeste antal tilladte mutationer.